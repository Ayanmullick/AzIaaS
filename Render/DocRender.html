<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>body { background-color: black; color: white; }
    a { color: #3CECFA; }
    .clear { clear: both; }
    table { border-collapse: collapse; border: 1px solid black; margin: 20px 0; }
    tr { border: 1px solid white; }
    th, td { border: 1px solid white; padding: 8px; text-align: left; }</style>
</head>
<body>
<div id="content"></div>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark-reasonable.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        marked.use({ break: true });

        function renderFileContent(markdownFileUrl) {
            renderMarkDownFile(markdownFileUrl);
        }

        async function renderMarkDownFile(fileUrl) {
            return fetch(fileUrl).then(response => response.text()).then(markdown => {
                const contentIncludesInfo = [], regexPattern = `\\[(.*)\\].+\\(% include(.+)%\\)(\\s*\\[align=([a-zA-Z]+)\\])?`, regex = new RegExp(regexPattern, "g");
                let groupIndex = 0;
                markdown = markdown.replaceAll(regex, (...groups) => {
                    groupIndex++;



                    const title = groups[1], path = groups[2].trim(), blockId = path.replace('.md', '') + groupIndex;
                    const includeInfo = { filePath: path, blockId: blockId };

                    if(groups[4]) includeInfo['alignPosition'] = groups[4];
                    contentIncludesInfo.push(includeInfo);
                    return `<details open id="${blockId}"><summary><strong><u>${title}</u></strong></summary></details>`;
                });

                document.getElementById("content").innerHTML = marked.parse(markdown);
                document.querySelectorAll("#content script").forEach(scriptTag => {
                    if (scriptTag.src) {
                        const externalScript = document.createElement("script");
                        externalScript.src = scriptTag.src;
                        document.getElementById("content").removeChild(scriptTag);
                        document.getElementById("content").appendChild(externalScript);
                    } else {
                        eval(scriptTag.innerText);
                    }
                });

                document.querySelectorAll("a").forEach(link => link.setAttribute("target", "_blank"));
                return contentIncludesInfo;
            }).then(contentIncludesInfo => {
                contentIncludesInfo.forEach(async includeInfo => {
                    let blockWrapper = '<div';
                    const fileContent = await getMarkdownFileContent(includeInfo.filePath.trim());
                    if(includeInfo['alignPosition']) blockWrapper += ` align=${includeInfo['alignPosition']}`;
                    document.getElementById(includeInfo.blockId).innerHTML += `${blockWrapper}>
          ${marked.parse(fileContent)}
        </div>`;
                });
            });
        }

        const urlParams = new URLSearchParams(window.location.search), path = urlParams.get("path");
        if (path !== "" && path !== null) renderFileContent(path);
    });

    var findBlocks = function (data, variableNames) {
        const matches = [];
        let variables = [];

        for (const [index, variable] of Object.entries(variableNames)) {
            variables.push(variable);
            const regexPattern = `#region(?<variableName> ${variable})(?<content>[\\s\\S]*?)(#endregion)`;
            let regex = new RegExp(regexPattern, "g");
            for (const match of data.matchAll(regex)) {
                const variableName = match.groups.variableName.trim();
                if (variables.includes(variableName)) {
                    matches.push({ variableName, content: match.groups.content.trim(), blockId:index });
                }
            }
        }
        return matches;
    };

    function showBlocks(data, variableNames) {
        findBlocks(data, variableNames).forEach((item) => {
            let variableNameBlock = document.getElementById(item.variableName), codeBlock = document.getElementById(item.blockId);
            if (codeBlock !== null) {
                codeBlock.textContent = item.content;
                hljs.highlightElement(codeBlock);
            }
            if (variableNameBlock !== null) variableNameBlock.textContent = item.variableName;
        });
    }

    function handleDocumentWrite(content) {
        document.getElementById("content").innerHTML += content;
    }
    window.document.write = handleDocumentWrite;

    async function getMarkdownFileContent(markdownFileUrl) {
        return fetch(markdownFileUrl).then(response => response.text());
    }
</script>
</body>
</html>